#!/bin/bash
# Setup a Hail batch deployment on Azure.
# Usage ./setup [-c]
#   -c: Clean up local and remote Terraform state.
#
# Script should follow style https://google.github.io/styleguide/shellguide.html
#
# Environment variables that need to be set or provided with `-f .env`. See also `example.env`.
#   - AAD_TENANT
#   - AZURE_SUBSCRIPTION
#   - DEPLOYMENT_NAME
#   - RESOURCE_GROUP_NAME
#   - LOCATION
#   - STORAGE_ACCOUNT
#   - TERRAFORM_CONTAINER
#   - SSH_PUBLIC_KEY

#############
# Constants #
#############

# Command line options.
readonly GETOPTS_STR="c"

#############
# Functions #
#############

err() {
  echo -e "${ANSI_RED}ERROR: $*${ANSI_RESET}" >&2
  exit 1
}


main() {
  # TODO handle failed/partial out of sync deployments, maybe a --destroy command (consistent with the terraform vernacular).
  # If pre-existing azure resources exist that are out of sync with the tf state, then terraform will throw an error stating that 
  # they need to be imported. At the least, we might want to validate that the resources we intend to create can be created before
  # kicking off terraform.

  # Process options.
  while getopts "${GETOPTS_STR}" option; do
    case "${option}" in
      c) should_clean="true";;
    esac
  done

  # Check if we are running the clean command.
  if [[ -n ${should_clean} ]]; then
    echo "Cleaning Terraform state."
    
    # Remove local Terraform state.
    rm -rf ".terraform"
    rm .terraform.lock.hcl
    rm out.plan

    # Remove Terraform container.
    # Probably better to go remove the resources you want to remove manually and not need az login for cleaning.
    #az storage container delete -n "${TERRAFORM_CONTAINER}" --account-name "${STORAGE_ACCOUNT}" --subscription "${AZURE_SUBSCRIPTION}" --auth-mode login

    exit 0
  fi

  # Report terraform version
  terraform -v

  # Report Azure CLI verison
  az --version

  # Load variables we need from a .env file if specified. Ignoring comments.
  if [ -f .env ]; then
      echo "Found .env file. Sourcing it."
    source ".env"
  else
    echo "No .env found, assuming environment variables are set already."
  fi

  # Login to Azure using the specified tenant if not already logged in.
  2>/dev/null az account get-access-token --tenant "${AAD_TENANT}" --output none
  if [[ $? -ne 0 ]] ; then
    echo "Login required to authenticate with Azure."
    echo "Attempting to login to Tenant: ${AAD_TENANT}"
    az login --output none --tenant "${AAD_TENANT}"
    if [[ $? -ne 0 ]]; then
      err "Failed to authenticate with Azure"
    fi
  fi

  # Set the subscription so future commands don't need to specifiy it.
  # TODO, looks like we still specify subscription many places below, we can either remove this or remove those arguments.
  az account set --subscription "${AZURE_SUBSCRIPTION}"

  # Create resource group if it doesn't exist.
  # When a resource group doesn't exist, the `az group exists` command returns anauthorization error.
  echo "Checking if resource group ${RESOURCE_GROUP_NAME} exists."
  rg_exists=$(az group exists -n "${RESOURCE_GROUP_NAME}" --subscription "${AZURE_SUBSCRIPTION}")
  if [[ $? -ne 0 ]]; then
    err "Failed to check for existence of resource group ${RESOURCE_GROUP_NAME} in subscription ${AZURE_SUBSCRIPTION}. Probably a permissions issue."
  fi
  if [[ ${rg_exists} == "true" ]]; then
    echo "Resource group ${RESOURCE_GROUP_NAME} already exists."
  else
    echo "Resource group ${RESOURCE_GROUP_NAME} does not exist."
    echo "Creating resource group ${RESOURCE_GROUP_NAME}"
    1>/dev/null az group create --name "${RESOURCE_GROUP_NAME}" --location "${LOCATION}"
    if [[ $? -ne 0 ]]; then
      err "Failed to create resource group ${RESOURCE_GROUP_NAME}"
    fi
  fi

  # Create storage account if it doesn't exist.
  # Uses jq to parse the json output and grab the "reason" field. -r for raw so there aren't quotes in the string.
  echo "Checking if storage account ${STORAGE_ACCOUNT} exists."
  sa_reason=$(az storage account check-name -n "${STORAGE_ACCOUNT}" --subscription "${AZURE_SUBSCRIPTION}" | jq -r .reason)
  # TODO This is probably checking the exit code of jq
  if [[ $? -ne 0 ]]; then
    err "Failed to check for existence of storage account ${STORAGE_ACCOUNT} in subscription ${AZURE_SUBSCRIPTION}. Probably a permissions issue."
  fi
  if [[ ${sa_reason} == "AlreadyExists" ]]; then
    echo "Storage account ${STORAGE_ACCOUNT} exists."
  else
    echo "Storage account ${STORAGE_ACCOUNT} does not exist. Creating it."
    1>/dev/null az storage account create --name "${STORAGE_ACCOUNT}" --resource-group "${RESOURCE_GROUP_NAME}" --location "${LOCATION}" --subscription "${AZURE_SUBSCRIPTION}"
    if [[ $? -ne 0 ]]; then
      err "Failed to create storage group ${STORAGE_ACCOUNT}"
    fi
  fi

  # Create container to store teraform information if it doesn't exist.
  # User should have "Storage Blob Data Contributor" role.
  # Uses jq to parse the json output and grab the "exists" field.
  container_exists=$(az storage container exists -n "${TERRAFORM_CONTAINER}" --account-name "${STORAGE_ACCOUNT}" --subscription "${AZURE_SUBSCRIPTION}" --auth-mode login | jq .exists)
  # TODO This is probably checking the exit code of jq
  if [[ $? -ne 0 ]]; then
    err "Failed to check for existence of container ${TERRAFORM_CONTAINER} in storage account ${STORAGE_ACCOUNT} in subscription ${AZURE_SUBSCRIPTION}. Probably a permissions issue."
  fi
  if [[ ${container_exists} == "false" ]]; then
      echo "Creating container ${TERRAFORM_CONTAINER}"
      1>/dev/null az storage container create -n "${TERRAFORM_CONTAINER}" --account-name "${STORAGE_ACCOUNT}" --subscription "${AZURE_SUBSCRIPTION}" --auth-mode login
  else
      echo "Container ${TERRAFORM_CONTAINER} exists."
  fi

  # Get an access key to the storage account.
  # Use jq to grabe the "value" field of the first key. "-r" option gives raw output without quotes.
  local sa_access_key=$(az storage account keys list --resource-group "${RESOURCE_GROUP_NAME}" --account-name "${STORAGE_ACCOUNT}" --subscription "${AZURE_SUBSCRIPTION}" | jq -r .[0].value)

  #### Create AKS cluster with Terraform ####

  # TODO, might need a check to verify the storage account and container are up and running at this point, script has failed once when needing to create the container, with a ContainerNotFound error message.
  
  # Initialize Terraform with a blob container to store state.
  terraform init -backend-config="storage_account_name=${STORAGE_ACCOUNT}" -backend-config="container_name=${TERRAFORM_CONTAINER}" -backend-config="access_key=${sa_access_key}" -backend-config="key=codelab.microsoft.tfstate"
  
  # TODO, consider using a .tfvars file. Can't directly replace .env because it doesn't support deriving one variable from another, which .env currently does.
  # might be about to write out the tfvars file programmatically here and then use that instead of all the -var args in terraform init/plan.

  # Import a newly created resource group into the configuration because we don't have perms to have Terraform be the creator of the resource group.
  terraform import  -var deployment_name="${DEPLOYMENT_NAME}" \
                    -var resource_group_name="${RESOURCE_GROUP_NAME}" \
                    -var location="${LOCATION}" \
                    -var ssh_public_key="${SSH_PUBLIC_KEY}" \
                    -var k8s_cluster_name="${K8S_CLUSTER_NAME}" \
                    "azurerm_resource_group.rg" "/subscriptions/${AZURE_SUBSCRIPTION}/resourceGroups/${RESOURCE_GROUP_NAME}"

  # Have Terraform create a plan and save it to file.
  terraform plan  -out out.plan \
                  -var deployment_name="${DEPLOYMENT_NAME}" \
                  -var resource_group_name="${RESOURCE_GROUP_NAME}" \
                  -var location="${LOCATION}" \
                  -var ssh_public_key="${SSH_PUBLIC_KEY}" \
                  -var k8s_cluster_name="${K8S_CLUSTER_NAME}"

  # Conditionally halt execution if plan failed.
  if [[ ! -f out.plan ]]; then
    err "Terraform plan failed. Halting execution."
  fi

  # Apply the Terraform configuation.
  terraform apply out.plan

  # Connect kubectl to newly created k8s cluster.
  # TODO, kubernetes cluster name should be deployment specific
  az aks get-credentials --resource-group "${RESOURCE_GROUP_NAME}" --name "${K8S_CLUSTER_NAME}"
  
  # Get the name for the default k8s config secret.
  k8s_secret_name=$(kubectl -n default get secret -o json | jq -r '.items[0].metadata.name')
  kubectl -n default get secret ${k8s_secret_name} -o json | jq '.data | map_values(@base64d)'
  # TODO update $HAIL/config.mk with the above information.


}

# Run main.
main "$@"
